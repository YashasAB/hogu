0) Install deps
npm i express multer cors mime-types @replit/object-storage
# (TypeScript users)
npm i -D typescript ts-node @types/node @types/express @types/multer @types/cors
Create a tsconfig.json with "types": ["node"] (TS only).
1) Minimal server (upload + download)
server.ts (or server.js)
import express from "express";
import cors from "cors";
import path from "path";
import multer from "multer";
import mime from "mime-types";

const app = express();
app.use(cors());
app.set("trust proxy", true);

// Multer: memory storage → file.buffer is a Node Buffer
const upload = multer({ storage: multer.memoryStorage() });

/** Coerce whatever the storage returns → Node Buffer */
function toNodeBuffer(v: unknown): Buffer {
  if (v == null) throw new Error("Empty storage value");
  if (Buffer.isBuffer(v)) return v;
  if (Array.isArray(v)) {
    const first = (v as any[])[0];
    if (Buffer.isBuffer(first)) return first;
    if (first instanceof Uint8Array) return Buffer.from(first.buffer, first.byteOffset, first.byteLength);
    throw new Error("Unexpected array type from storage");
  }
  if (v instanceof Uint8Array) return Buffer.from(v.buffer, v.byteOffset, v.byteLength);
  if (v instanceof ArrayBuffer) return Buffer.from(v);
  if (typeof v === "string") {
    if (v.startsWith("data:image/")) {
      const base64 = v.split(",")[1] ?? "";
      return Buffer.from(base64.replace(/\s+/g, ""), "base64");
    }
    try { return Buffer.from(v.replace(/\s+/g, ""), "base64"); } catch { return Buffer.from(v, "utf8"); }
  }
  throw new Error("Unsupported storage value");
}

/** Very small mime sniffer (fallback to extension) */
function sniffContentType(buf: Buffer, filename: string): string {
  const sig4 = buf.subarray(0, 4).toString("hex");
  if (sig4.startsWith("ffd8")) return "image/jpeg";
  if (sig4 === "89504e47") return "image/png";
  if (buf.subarray(0, 4).toString("ascii") === "RIFF" && buf.subarray(8, 12).toString("ascii") === "WEBP") return "image/webp";
  if (sig4.startsWith("4749")) return "image/gif";
  if (filename.toLowerCase().endsWith(".svg")) return "image/svg+xml";
  const ext = filename.split(".").pop()?.toLowerCase();
  if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
  if (ext === "png") return "image/png";
  if (ext === "gif") return "image/gif";
  if (ext === "webp") return "image/webp";
  return "application/octet-stream";
}

/** ===================== UPLOAD ===================== **
 * POST /api/images/:tenantId/upload
 * form-data field name: "image"
 */
app.post("/api/images/:tenantId/upload", upload.single("image") as any, async (req, res) => {
  try {
    const { tenantId } = req.params;
    const file = req.file;
    if (!file) return res.status(400).json({ error: "No image file provided" });
    if (!file.mimetype.startsWith("image/")) return res.status(400).json({ error: "Only image uploads allowed" });

    const extFromMime = (mime.extension(file.mimetype) || "").toLowerCase();
    const extFromName = (file.originalname.split(".").pop() || "").toLowerCase();
    const ext = (extFromMime || extFromName || "jpg").replace("jpeg", "jpg");

    // Store at: <tenantId>/heroImage.<ext> (or use any naming you want)
    const objectKey = `${tenantId}/heroImage.${ext}`;

    const { Client } = await import("@replit/object-storage");
    const storage = new Client();

    // Multer gives a Node Buffer already
    const buf: Buffer = Buffer.isBuffer(file.buffer) ? file.buffer : Buffer.from(file.buffer as ArrayBufferLike);

    // Upload BYTES (not text)
    const up: any = await (storage as any).uploadFromBytes(objectKey, buf /*, {
      contentType: file.mimetype,
      cacheControl: "public, max-age=31536000, immutable",
    }*/);

    if (!up?.ok) {
      const msg = up?.error?.message || JSON.stringify(up?.error) || "Unknown storage error";
      return res.status(500).json({ error: `Storage upload failed: ${msg}` });
    }

    // Return a stable proxy URL your FE can use directly
    const imageUrl = `/api/images/${tenantId}/heroImage.${ext}`;
    return res.json({ message: "ok", imageUrl });
  } catch (e) {
    console.error("upload error:", e);
    return res.status(500).json({ error: "Failed to upload image" });
  }
});

/** ===================== DOWNLOAD ===================== **
 * GET /api/images/:tenantId/:filename
 */
app.get("/api/images/:tenantId/:filename", async (req, res) => {
  try {
    const { tenantId, filename } = req.params;
    const key = `${tenantId}/${filename}`;

    const { Client } = await import("@replit/object-storage");
    const storage = new Client();

    const out: any = await storage.downloadAsBytes(key);
    if (!out?.ok) return res.status(404).json({ error: "Image not found", key, details: out?.error });

    // Whatever it is (Buffer, [Buffer], Uint8Array…) → Buffer
    let buf = toNodeBuffer(out.value);

    // Decode if someone ever saved base64/data URL by mistake
    const head = buf.subarray(0, 128).toString("utf8");
    if (head.startsWith("data:image/")) {
      const base64 = buf.toString("utf8").split(",")[1] ?? "";
      buf = Buffer.from(base64.replace(/\s+/g, ""), "base64");
    } else if (/^[A-Za-z0-9+/=\r\n]{24,}$/.test(head)) {
      try {
        const dec = Buffer.from(buf.toString("utf8").replace(/\s+/g, ""), "base64");
        if (dec.length) buf = dec;
      } catch {}
    }

    const contentType = sniffContentType(buf, filename);
    res.set({
      "Content-Type": contentType,
      "Cache-Control": "public, max-age=31536000, immutable",
      "Access-Control-Allow-Origin": "*",
    });

    return res.end(buf); // raw bytes
  } catch (e) {
    console.error("download error:", e);
    return res.status(500).json({ error: "Error loading image" });
  }
});

// (Optional) SPA serving — keep AFTER the /api routes and exclude /api
if (process.env.NODE_ENV === "production") {
  const webDist = path.join(__dirname, "web", "dist");
  app.use(express.static(webDist, { index: false }));
  app.get(/^\/(?!api\/).*/, (_req, res) => res.sendFile(path.join(webDist, "index.html")));
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server on :${PORT}`));
✅ Keys (paths inside the bucket) should look like tenantId/heroImage.jpg. Do not include a bucket name in the key.
2) Tiny frontend to test (upload + display)
index.html (put in web/ or root; adjust paths if using Vite/React)
<!doctype html>
<html>
  <body>
    <h1>Replit Object Storage – Image Demo</h1>

    <form id="uform">
      <input type="text" id="tenant" placeholder="tenantId (e.g. restaurant123)" required />
      <input type="file" id="file" accept="image/*" required />
      <button>Upload</button>
    </form>

    <p id="status"></p>

    <h3>Preview</h3>
    <img id="preview" style="max-width: 480px; border: 1px solid #ccc" />

    <script>
      const statusEl = document.getElementById("status");
      const imgEl = document.getElementById("preview");
      const form = document.getElementById("uform");

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const tenantId = document.getElementById("tenant").value.trim();
        const file = document.getElementById("file").files[0];
        if (!tenantId || !file) return;

        const fd = new FormData();
        fd.append("image", file);

        statusEl.textContent = "Uploading...";
        const res = await fetch(`/api/images/${encodeURIComponent(tenantId)}/upload`, {
          method: "POST",
          body: fd,
        });
        const json = await res.json();
        if (!res.ok) {
          statusEl.textContent = "Upload failed: " + (json.error || res.statusText);
          return;
        }
        statusEl.textContent = "Uploaded!";
        // Display using the proxy URL returned by the server
        imgEl.src = json.imageUrl + `?t=${Date.now()}`;
      });
    </script>
  </body>
</html>
If you run a front-end dev server (e.g., Vite/React), either:
use an absolute API base (VITE_API_BASE) for fetches, or
add a dev proxy for /api to your Express port.
Vite dev proxy example (optional):
// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: { "/api": { target: "http://localhost:3000", changeOrigin: true } },
  },
});
3) Quick curl tests
# Upload
curl -F "image=@/path/to/pic.jpg" http://localhost:3000/api/images/tenant123/upload

# Download headers (should be image/*)
curl -I http://localhost:3000/api/images/tenant123/heroImage.jpg

# First 4 bytes (JPEG ffd8, PNG 89504e47, etc.)
curl -s http://localhost:3000/api/images/tenant123/heroImage.jpg | xxd -l 4 -p
Common gotchas (super short)
text/html in response? SPA catch-all is intercepting /api. Put API routes before it and guard with regex ^\/(?!api\/).*.
Broken image (“?”) usually means not image/* bytes (HTML/json/base64 text) or wrong path/extension. This server decodes base64/data URLs and sniffs the content type.
Don’t include bucket name in the key. Keys are just “folders” inside the bucket: tenantId/file.ext.
That’s it—drop this in and you’ll be able to upload, fetch, and display images from Replit Object Storage cleanly.