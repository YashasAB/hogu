// Small helper: whatever comes back -> Node Buffer
function toNodeBuffer(v: unknown): Buffer {
  if (Buffer.isBuffer(v)) return v;
  if (v instanceof Uint8Array) return Buffer.from(v.buffer, v.byteOffset, v.byteLength);
  if (Array.isArray(v) && v[0]) {
    const first = (v as any[])[0];
    if (Buffer.isBuffer(first)) return first;
    if (first instanceof Uint8Array) return Buffer.from(first.buffer, first.byteOffset, first.byteLength);
  }
  throw new Error("Unexpected storage value type");
}

// Minimal signature sniff (fallback to extension)
function detectContentType(buf: Buffer, filename: string): string {
  const hex4 = buf.subarray(0, 4).toString("hex");
  if (hex4.startsWith("ffd8")) return "image/jpeg";
  if (hex4 === "89504e47") return "image/png";
  if (buf.subarray(0,4).toString("ascii")==="RIFF" && buf.subarray(8,12).toString("ascii")==="WEBP") return "image/webp";
  if (hex4.startsWith("4749")) return "image/gif";
  if (filename.toLowerCase().endsWith(".svg")) return "image/svg+xml";
  const ext = filename.split(".").pop()?.toLowerCase();
  if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
  if (ext === "png") return "image/png";
  if (ext === "gif") return "image/gif";
  if (ext === "webp") return "image/webp";
  return "application/octet-stream";
}

app.get("/api/images/storage/:tenantId/:filename", async (req, res) => {
  try {
    const { tenantId, filename } = req.params;
    const key = `${tenantId}/${filename}`;

    const { Client } = await import("@replit/object-storage");
    const storage = new Client();

    const out: any = await storage.downloadAsBytes(key);
    if (!out?.ok || !out?.value) {
      return res.status(404).json({ error: "Image not found", key, details: out?.error });
    }

    // Ensure we have raw binary
    const buf = toNodeBuffer(out.value);

    // Pick the correct image/* (NO charset)
    const ct = detectContentType(buf, filename);

    // Set headers explicitly. Do NOT use res.type()/res.contentType() (they can append charset).
    res.setHeader("Content-Type", ct);
    res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
    res.setHeader("Access-Control-Allow-Origin", "*");
    // Ensure no conflicting header sneaks in from global CORS middleware:
    res.removeHeader?.("Access-Control-Allow-Credentials");

    // Let Express compute Content-Length; just send bytes
    return res.end(buf);
  } catch (err) {
    console.error("image proxy error:", err);
    return res.status(500).json({ error: "Error loading image" });
  }
});

// (Optional) HEAD – nice for CDNs/proxies
app.head("/api/images/storage/:tenantId/:filename", async (req, res) => {
  // You can reuse logic above to set headers without sending the body,
  // or simply 200 with cache headers if you don’t need exact length.
  res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.sendStatus(200);
});
