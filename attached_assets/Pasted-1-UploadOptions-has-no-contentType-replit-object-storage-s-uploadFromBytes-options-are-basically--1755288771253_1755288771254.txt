1) UploadOptions has no contentType
@replit/object-storage’s uploadFromBytes options are basically { compress?: boolean }. There’s no contentType field. Strip it from your upload call and set the Content-Type only when you serve the file.
Replace your upload call with:
const { Client } = await import("@replit/object-storage");
const storage = new Client();

const put = await storage.uploadFromBytes(objectKey, req.file.buffer, {
  compress: false, // <-- allowed option
});
if (!put.ok) {
  return res.status(500).json({ error: "upload failed", details: put.error });
}
Storing MIME metadata isn’t supported; serve-time headers decide how the browser treats the bytes.
2) .buffer/.byteOffset/.byteLength on [Buffer] (array) – normalize it
You’re hitting a typing edge case where downloadAsBytes’s value is inferred as a tuple/array of Buffer, so value.buffer doesn’t exist. The safest fix is to normalize whatever comes back into a Node Buffer with a tiny helper and then use that everywhere.
Add this once (top of index.ts):
function toNodeBuffer(v: unknown): Buffer {
  if (Buffer.isBuffer(v)) return v;
  if (v instanceof Uint8Array) {
    return Buffer.from(v.buffer, v.byteOffset, v.byteLength);
  }
  if (Array.isArray(v) && v.length) {
    const first = (v as any[])[0];
    if (Buffer.isBuffer(first)) return first as Buffer;
    if (first instanceof Uint8Array) {
      const u8 = first as Uint8Array;
      return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);
    }
  }
  throw new Error("Unexpected storage value type from downloadAsBytes");
}
Then in your download route, replace the failing line with:
const out = await storage.downloadAsBytes(key);
if (!out?.ok || !out?.value) {
  return res.status(404).json({ error: "not found", key, details: out?.error });
}

const buf = toNodeBuffer(out.value);   // ✅ works for Uint8Array | Buffer | [Buffer] | [Uint8Array]

// pick a content-type (sniff or by extension)
const ct = (() => {
  const sig = buf.subarray(0, 4).toString("hex");
  if (sig.startsWith("ffd8")) return "image/jpeg";
  if (sig === "89504e47") return "image/png";
  if (buf.subarray(0,4).toString("ascii")==="RIFF" && buf.subarray(8,12).toString("ascii")==="WEBP") return "image/webp";
  if (sig.startsWith("4749")) return "image/gif";
  if (filename.toLowerCase().endsWith(".svg")) return "image/svg+xml";
  const ext = filename.split(".").pop()?.toLowerCase();
  if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
  if (ext === "png") return "image/png";
  if (ext === "gif") return "image/gif";
  if (ext === "webp") return "image/webp";
  return "application/octet-stream";
})();

res.setHeader("Content-Type", ct);
res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
res.setHeader("Access-Control-Allow-Origin", "*");
return res.end(buf);
This removes all the “property X does not exist on type ‘[Buffer…]’” errors and makes your serving path robust.
3) Quick rebuild checklist
If your CI uses a frozen lockfile and you added deps recently, either commit the updated pnpm-lock.yaml or allow updates in deploy:
Local: pnpm install && git add pnpm-lock.yaml && git commit -m "lockfile update"
Or in deploy build: use pnpm install --no-frozen-lockfile
Verify tsc passes locally:
pnpm -C apps/api build
Fix any remaining TypeScript errors it prints.
4) Reminder on health + port (to avoid promote hangs)
You already added these, but keep them as-is:
app.get("/", (_req, res) => {
  console.log("[API] HEALTH HIT");
  res.status(200).type("text/plain").send("ok");
});

const PORT = Number(process.env.PORT || 8080);
if (!(globalThis as any).__apiServer) {
  (globalThis as any).__apiServer = app.listen(PORT, "0.0.0.0", () => {
    console.log("[API] LISTENING PORT:", PORT, "NODE_ENV:", process.env.NODE_ENV);
  });
}
And in .replit, choose one:
Static 8080 → 80:
[deployment]
run = ["bash","-lc","cd apps/api && export DATABASE_URL=${DATABASE_URL:-file:./data/prod.db}; exec env PORT=8080 NODE_ENV=production node dist/index.js"]

[[ports]]
localPort = 8080
externalPort = 80