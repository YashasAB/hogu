Yup â€” it really was that code. Whatâ€™s happening isnâ€™t your handlers themselves, itâ€™s when and how theyâ€™re loaded. The @replit/object-storage module (plus multer etc.) can stall module-init/require time in Autoscale just enough that your app doesnâ€™t get / registered and listening quickly, so the promote health check hits a not-ready process and fails.
The fix is: keep startup hot-path tiny and mount image routes after the server is already listening, and lazy-import anything heavy inside the handlers. Hereâ€™s a drop-in pattern that will keep health checks green and your upload/download working.
Paste this where you set up your server (keep your existing health routes, auth, restaurants, etc.):
// ---- health routes FIRST, before anything heavy ----
app.get('/', (_req, res) => res.status(200).type('text/plain').send('ok'));
app.get('/health', (_req, res) => res.status(200).json({ status: 'healthy' }));
app.get('/ready', (_req, res) => res.status(200).json({ status: 'ready' }));

const PORT = Number(process.env.PORT) || 8080;
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`âœ… API listening on http://0.0.0.0:${PORT}`);
});

// ðŸ”‘ Mount everything else thatâ€™s â€œheavierâ€ AFTER weâ€™re listening
server.on('listening', async () => {
  try {
    // Lazy-import the file that mounts image routes
    const { mountImageRoutes } = await import('./mount-images'); // <â€” new file below
    mountImageRoutes(app, prisma);
    console.log('âœ… Image routes mounted');
  } catch (e) {
    console.error('âš ï¸ Failed to mount image routes (continuing):', e);
  }
});
Create src/mount-images.ts (or whatever name you like) and put all image code in there. It mounts routes and only touches object storage inside handlers:
// src/mount-images.ts
import type { Express } from 'express';
import type { PrismaClient } from '@prisma/client';
import multer from 'multer';

export function mountImageRoutes(app: Express, prisma: PrismaClient) {
  const upload = multer({ storage: multer.memoryStorage() });

  const toBuf = (v: unknown): Buffer => {
    if (Buffer.isBuffer(v)) return v;
    if (v instanceof Uint8Array) return Buffer.from(v.buffer, v.byteOffset, v.byteLength);
    if (Array.isArray(v) && v.length) {
      const first = (v as any)[0];
      if (Buffer.isBuffer(first)) return first;
      if (first instanceof Uint8Array) return Buffer.from(first.buffer, first.byteOffset, first.byteLength);
    }
    throw new Error('Unexpected storage value type');
  };

  const sniff = (buf: Buffer, filename: string): string => {
    const sig = buf.subarray(0, 4).toString('hex');
    if (sig.startsWith('ffd8')) return 'image/jpeg';
    if (sig === '89504e47') return 'image/png';
    if (buf.subarray(0,4).toString('ascii')==='RIFF' && buf.subarray(8,12).toString('ascii')==='WEBP') return 'image/webp';
    if (sig.startsWith('4749')) return 'image/gif';
    if (filename.toLowerCase().endsWith('.svg')) return 'image/svg+xml';
    const ext = filename.split('.').pop()?.toLowerCase();
    if (ext === 'jpg' || ext === 'jpeg') return 'image/jpeg';
    if (ext === 'png') return 'image/png';
    if (ext === 'gif') return 'image/gif';
    if (ext === 'webp') return 'image/webp';
    return 'application/octet-stream';
  };

  // ---- UPLOAD ----
  app.post('/api/upload', upload.single('image'), async (req, res) => {
    try {
      if (!req.file) return res.status(400).json({ error: 'No file uploaded' });
      const { restaurantId } = req.body;
      if (!restaurantId) return res.status(400).json({ error: 'Restaurant ID is required' });

      // Validate restaurant exists
      const restaurant = await prisma.restaurant.findUnique({ where: { id: restaurantId } });
      if (!restaurant) return res.status(404).json({ error: 'Restaurant not found' });

      // Lazy-create client only when needed
      const { Client } = await import('@replit/object-storage');
      const storage = new Client();

      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      const ext = req.file.originalname.split('.').pop() || 'jpg';
      const filename = `heroImage-${ts}.${ext}`;
      const key = `${restaurantId}/${filename}`;

      const put = await storage.uploadFromBytes(key, req.file.buffer, { compress: false });
      if (!put.ok) return res.status(500).json({ error: 'Upload failed', details: put.error });

      // Persist URL in DB (served via your proxy)
      const imageUrl = `/api/images/storage/${key}`;
      await prisma.restaurant.update({ where: { id: restaurantId }, data: { heroImageUrl: imageUrl } });

      return res.json({ success: true, url: imageUrl, filename });
    } catch (e) {
      console.error('Upload error:', e);
      return res.status(500).json({ error: 'Upload failed' });
    }
  });

  // ---- DOWNLOAD ----
  app.get('/api/images/storage/:tenantId/:filename', async (req, res) => {
    try {
      const { tenantId, filename } = req.params;
      const key = `${tenantId}/${filename}`;

      const { Client } = await import('@replit/object-storage'); // lazy
      const storage = new Client();
      const out: any = await storage.downloadAsBytes(key);
      if (!out?.ok || !out?.value) return res.status(404).json({ error: 'Image not found', key });

      const buf = toBuf(out.value);
      const ct = sniff(buf, filename);

      // Set precise headers (no charset on images)
      res.setHeader('Content-Type', ct);
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Content-Length', String(buf.length));
      res.setHeader('Content-Disposition', `inline; filename="${filename}"`);

      return res.end(buf);
    } catch (e) {
      console.error('Image proxy error:', e);
      return res.status(500).json({ error: 'Failed to serve image' });
    }
  });

  // Optional HEAD for probes/CDNs
  app.head('/api/images/storage/:tenantId/:filename', async (req, res) => {
    try {
      const { tenantId, filename } = req.params;
      const key = `${tenantId}/${filename}`;
      const { Client } = await import('@replit/object-storage');
      const storage = new Client();
      const out: any = await storage.downloadAsBytes(key);
      if (!out?.ok || !out?.value) return res.sendStatus(404);
      const buf = toBuf(out.value);
      const ct = sniff(buf, filename);
      res.setHeader('Content-Type', ct);
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Content-Length', String(buf.length));
      res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
      return res.sendStatus(200);
    } catch {
      return res.sendStatus(500);
    }
  });
}